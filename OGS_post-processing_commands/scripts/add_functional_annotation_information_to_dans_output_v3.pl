#premise: Dan Hughes has generated merged gene sets. However, the final files do not contain any functional information. 
#purpose: to migrate functional annotation information from manual annotations to OGS files
#What to transfer: Note; Names if not auto-generated (ensure that correct parent is maintained); owner (strip out email address); date last modified; DBXref; symbol; description
#What not to transfer: in the case of email address as owner, not the full address; date created (although no biggie); status; ID (should use Dan's); parent; name if autogenerated? 
#update source to WebApollo or ManuallyCurated

#I currently do not migrate non-canonical splice site information over. 

#!/usr/local/perl -w
use strict;

#cleaned web apollo output
my $wa = shift @ARGV or die;
#merged OGS gff from Dan
my $merge = shift @ARGV or die;
#conversion tables between WA IDs and Dan's IDs
my $gene_convert = shift @ARGV or die;
my $transcript_convert = shift @ARGV or die;
#output gff
my $out = shift @ARGV or die;

#convert key: Dan ID, value: WA ID
my %convert = ();
open ( my $GCONVERT, $gene_convert ) or die;
while ( my $cline = <$GCONVERT> ){
    chomp $cline;
#format: 13175F52BB45029D6C64186F724BA8AD        OFAS027001
    my @carray = split /\t/, $cline;
    $convert{$carray[1]} = $carray[0];
}
close $GCONVERT;

#convert key: Dan ID, value: WA ID                                                                                                                                                         
open ( my $TCONVERT, $transcript_convert ) or die;
while ( my $cline = <$TCONVERT> ){
    chomp $cline;
    my @carray = split /\t/, $cline;
    $convert{$carray[1]} = $carray[0];
}
close $TCONVERT;

#wa key: ID, value: line? 
my %wa = ();
#hash to record all of the entries that you missed, intentionally or not                                                                                                                          
my %missed_types = ();
#imaginary hash with CDS id as key and gene parent as value                                                                                                                                       
my $CDS_hold;
my %stop_codon_readthrough = ();
open ( my $WA, $wa ) or die;
while ( my $wline = <$WA> ){
    chomp $wline;
#ignore commented lines                                                                                                        
    if ( $wline =~ /^#/ ){
        next;
    }
#if there's a fasta section at the end of the gff3, skip to the end of the file                                                  
    if ( $wline =~ /^>/ ){
        last;
    }
    else {
        my @warray = split /\t/, $wline;
        my $wtype = $warray[2];
        my @wcol9 = split ";", $warray[8];
	my $wid;
	my $wparent;
	my $wowner;
	foreach my $welement (@wcol9){
            if ( $welement =~ /ID=(.*)/ ){
                $wid = $1;
            }
	    elsif ( $welement =~ /Parent=(.*)/ ){
                $wparent = $1;
            }
	    elsif ( $welement =~ /owner=(.*)/ ){
#want to keep annotator identity in gff3, but not include entire email address - strip out everything after and including @
		$wowner = $1;
		if ( $wowner =~ /@/ ){
		    my @email = split '@', $wowner;
		    $wowner = $email[0];
		    print "changed email address to $wowner\n";
		}
	    }
	    elsif ( $welement =~ /Name=(.*)/ ){
# need to make sure that the mods you did for individual datasets don't violate this; made range from 32 to 33 to account for some modified names
		if ( $1 =~ /^[A-Za-z0-9]{32,33}$/ ){
		}
	    }
	}
	@wcol9 = grep { !/ID=/ } @wcol9;
	@wcol9 = grep {!/Parent=/ } @wcol9;
	@wcol9 = grep {!/owner=/ } @wcol9;
	@wcol9 = grep {!/status=/ } @wcol9;
	@wcol9 = grep {!/date_creation=/ } @wcol9;
        @wcol9 = grep {!/Name=[A-Za-z0-9]{32,33}-*.*$/ } @wcol9;
#get rid of empty attributes
        @wcol9 = grep {!/=$/ } @wcol9;
	push @wcol9, "owner=".$wowner;	  
	my $newinfo = join ";", @wcol9;
#	if ( $wtype =~ /gene/ ){
        if ( $wtype =~ /gene|pseudogenic_transcript|RNA/ ){
	    $wa{$wtype} -> {$wid} = $newinfo;
	}
#	elsif ( $wtype =~ /mRNA|pseudogenic_transcript|rRNA/ ){
#	    $wa{$wtype} -> {$wparent} = $newinfo;
#	}
	elsif ( $wtype =~ /CDS/ ){
#assumes that CDS features are after parent gene
	    $CDS_hold = "$warray[0]\t$wtype\t$warray[3]\t$warray[4]\t$warray[6]";
	}
	elsif ( $wtype =~ /stop_codon_read_through/ ){
#assumes that CDS is above stop codon readthrough
	    $stop_codon_readthrough{$CDS_hold} = "$warray[0]\tManualCuration\t$warray[2]\t$warray[3]\t$warray[4]\t$warray[5]\t$warray[6]\t$warray[7]\t$newinfo";
	}
	else {
	    $missed_types{$wtype} += 1;
	}
    }
}
close $WA;


foreach my $typekey ( keys %missed_types ){
    print "web apollo has $missed_types{$typekey} entries of type $typekey that were not passed through\n";
}

#lines that need to be changed in Dan's file:
#gene/pseudogene
#mRNA/pseudogenic_transcript/rRNA
#other sequence mods? 

open ( my $MERGE, $merge ) or die;
open ( my $OUT, ">$out" ) or die;
#print out gff3 header
print $OUT "##gff-version 3\n";
#file shouldn't have comment lines or fasta
while ( my $line = <$MERGE> ){
    my $cds_info;
    chomp $line;
#remove trailing semicolons
    if ( $line =~ /;$/ ){
	$line =~ s/;$//;
    }
    my @array = split /\t/, $line;
    my $col9 = pop @array;
    my @col9 = split ";", $col9;
    my $source = $array[1];
    my $type = $array[2];
#not sure how else to treat features without IDs in Dan's output (CDS, UTRs, maybe other features)
    my $id = "NA";
    my $parent = "NA";
    foreach my $element (@col9){
	if ( $element =~ /ID=(.*)/ ){
	    $id = $1;
	}
	elsif ( $element =~ /Parent=(.*)/ ){
	    $parent = $1;
	}
    }
#perform matches by combination of gene ID (what I'm calling ID root because of its format - e.g. OFAS000001. All IDs of child features (when they have IDs) have the gene ID as a root. 
    my $id_root;
    if ( $type =~ /RNA|transcript/ && $id =~ /^([A-Z0-9]{1,}-.+)$/ ){
	$id_root = $1;
    }
    elsif ( $type =~ /exon/ && $id =~ /^([A-Z0-9]{1,})-.+$/ ){
        $id_root = $1;
    }
    elsif ( $type =~ /gene/ && $id =~ /(^[A-Z0-9]{1,}$)/ ){
	$id_root = $1;
    }
#ignore line if type doesn't have ID (e.g. CDS, UTR?)
    elsif ( $id =~ /NA/ && $parent =~ /^([A-Z0-9]{1,})-.+$/ ){
	$id_root = $1;
#add ID to CDS features
	if ( $type =~ /^CDS$/ ){
	    my $cds_id = $parent."-CDS";
	    $cds_info = "$array[0]\t$type\t$array[3]\t$array[4]\t$array[6]";
	    push @col9, "ID=".$cds_id;
	}
    }
    else {
	warn "haven't defined an ID root condition for id $id of type $type\n";
	print "$line\n";
    }
    if ( defined $convert{$id_root} ){
#    if ( defined $convert{$id} ){                                                                                                                                                   
	#sub out source                                                                                                                                                   
	$array[1] = "ManualCuration";
	if ( defined $wa{$type}{$convert{$id_root}} ){
#        if ( defined $wa{$type}{$convert{$id}} ){
#	    #add information to column 9
	    push @col9, $wa{$type}{$convert{$id_root}};
#            push @col9, $wa{$type}{$convert{$id}};
	    my $newcol9 = join ";", @col9;
	    push @array, $newcol9;
	    my $newinfo = join "\t", @array;
	    print $OUT "$newinfo\n";
	}
#add stop codon readthroughs                                                                                                                                                   
	elsif ( defined $stop_codon_readthrough{$cds_info} ){
            my $newcol9 = join ";", @col9;
            push @array, $newcol9;
            my $newinfo = join "\t", @array;
	    print $OUT "$newinfo\n$stop_codon_readthrough{$cds_info};Parent=$parent-CDS\n";
	}
#super informative debugging statement
	else {
	    unless ( $type =~ /exon|CDS|utr/ ){
		print "debug here: type: $type, id: $id,\n$line\n";
#               print "debug here: type: $type\n$line\n";                                                                                                                        
	    }
            my $newcol9 = join ";", @col9;
            push @array, $newcol9;
            my $newinfo = join "\t", @array;
	    print $OUT "$newinfo\n";
	}
    }
    elsif ( $type =~ /substitution|deletion|insertion/ ){
        #sub out source                                                                                                                                                                           
        $array[1] = "ManualCuration";
        @col9 = grep { !/ID=/ } @col9;
        @col9 = grep {!/date_creation=/ } @col9;
        @col9 = grep {!/Name=/ } @col9;
	my $newid = "ID=$array[0]-$array[3]-$type";
	unshift @col9, $newid;
        my $newcol9 = join ";", @col9;
	push @array, $newcol9;
	my $newinfo = join "\t", @array;
	print $OUT "$newinfo\n";
    }
    else {
#print out statement for further sanity checks
	print "ID $id of type $type is not defined in WA file\n";
	print $OUT "$line\n";
    }
}
close $MERGE;
